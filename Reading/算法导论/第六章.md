##### 6.1-5 一个已排好序的数组是一个最小堆吗？

​	按升序排好的数组必然是一个最小堆。最小堆的条件是A[parent(i)] <= A[i]，而i必然大于parent(i)，而由于是升序数组，最小堆的条件也自然满足。

##### 6.1-7 证明：当用数组表示存储n个元素的堆时，叶结点下标分别是n/2+1,n/2+2,……,n.

​	堆是完全二叉树，这个性质使得其叶子结点的下标必然连续。要证明的就是第一个叶子结点的下标为n/2+1。

​	而一个结点的左孩子下标为自己下标的两倍，而最后一个拥有孩子结点的下标设为k，那么2k<=n，即k<=n/2，即最后一个有孩子节点的下标为n/2，那么第一个叶子结点就是n/2+1

##### 6.2-1 参照图6-2的方法，说明MAX-HEAPIFY(A,3)在数组A={27，17，3，16，13，10，1，5，7，12，4，8，9，0}上的操作过程。

​	{27，17，3，16，13，10，1，5，7，12，4，8，9，0}

​	{27，17，10，16，13，3，1，5，7，12，4，8，9，0}

​	{27，17，3，16，13，9，1，5，7，12，4，8，3，0}

##### 6.2-2 参考过程MAX-HEAPIFY,写出能够维护相应最小堆的MIN-HEAPIFY（A，i）的伪代码，并比较MIN-HEAPIFY与MAX-HEAPIFY的运行时间。

```
MIN-HEAPIFY（A，i）{
	l = LEFT(i);
	r = RIGHT(i);
	if(l <= A.heap_size && A[l] < A[i])
		minimum = l;
	else
		minimum = i;
	if(r <= A.heap_size && A[r] < A[minimum])
		minimum = r;
	if(minimum != i){
		exchange(A[i],A[minimum]);
		MIN_HEAPIFY(A,minimum);
	}
}
```

应该是一样的吧……或者代码写的有问题？搞不懂，感觉这个伪代码没什么问题，然后最大堆和最小堆的维护似乎一模一样，时间效率什么的应该没什么差别。

##### 6.2-4 当i>A.heap-size/2时，调用MAX-HEAPIFY（A，i）会有什么结果？

​	调用时可以看见，l和r分别是2*i和 2\*i+1，已经超过了两个if判断的范围，并且最后一个if中largest等于i，好像陷入了死循环……（？）伪代码少了个递归出口条件判断的样子。爬！自己没理解人家伪代码，搁着瞎胡闹呐？人家用缩进表示代码块，不是用C风格好吗？加了个括号没问题了，会直接结束函数调用。

##### 6.2-5 MAX-HEAPIFY的代码效率较高，但第10行中的递归调用可能例外，它可能使某些编译器产生低效的代码。请用循环控制结构取代递归，重写MAX-HEAPIFY代码。

​	这个还是好写的，感觉思想很容易理解。

​	原MAX-HEAPIFY代码：

```
MAX-HEAPIFY（A，i）{
	l = LEFT(i);
	r = RIGHT(i);
	if(l <= A.heap_size && A[l] > A[i])
		largest = l;
	else
		largest = i;
	if(r <= A.heap_size && A[r] > A[largest])
		largest = r;
	if(largest != i){
		exchange(A[i],A[largest]);
		MAX_HEAPIFY(A,largest);
	}
}
```

​	去掉递归改用循环的伪代码：

```
MAX-HEAPIFY（A，i){
	while(i <= A.head_size/2){
		l = LEFT(i);
		r = RIGHT(i);
		if(l <= A.heap_size && A[l] > A[i])
			largest = l;
        else
            largest = i;
        if(r <= A.heap_size && A[r] > A[largest])
            largest = r;
        if(largest != i){
            exchange(A[i],A[largest]);
            i = largest;
        }
        else{
        //当A[i]比两个孩子结点都大时，表示已经是最大堆（MAX-HEAPIFY（A，i）方法的使用前提是两个孩子都是最大堆的根节点，只有当前结点i不确定是否满足条件。如果i满足条件，则跳出循环。
        	break;
        }
	}
}
```

##### 6.3-2 对于BUILD-MAX-HEAP中第2行的循环控制变量i来说，为什么我们要求它是从A.length/2 到 1递减，而不是从1到A.length/2递增呢？

​	个人想法，后者的情况下，从1开始调用Max-heapify的情况下，无法保证调用的条件满足。也就是左右子树并不是最大堆的情况下，调用max-heapify不能保证正确性，也就是并不能保证最大值上浮到对应的结点（子树不是最大堆，那么第一次比较获得的就不一定是子树中的最大值，而build-max-heap又不会回溯重新比较，因而并不正确）

##### 6.3-3 证明：对于任一包含n个元素的堆中，至多有n/2^(h+1)（向上取整）个高度为h的结点？

##### 6.4-3 对于一个按升序排列的包含n个元素的有序数组A来说，HEAPSORT的时间复杂度是多少？如果A是降序呢？

​	